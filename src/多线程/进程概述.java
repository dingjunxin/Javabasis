package 多线程;

/**
 * 进程：是一个正在执行中的程序
 *      每一个进程执行都要有个执行顺序，该瞬狙是一个执行路径，或者二叫一个控制单元
 * 线程：就是进程中的一个独立的控制单元。
 *          线程在控制着进程的执行
 *      一个进程至少有一个线程
 *
 * java VM：启动的时候会有一个进程java.exe。
 * 该进程当中至少有一个线程。负责java程序的执行。
 * 而且这个线程运行的代码存在于main方法中
 * 该线程称之为主线程
 *
 * 扩展：其实更细节说明虚拟机（jvm），jvm启动不止一个线程，还有负责垃圾回收机制的线程。
 *
 * 通过对api的查找，java已经提供了对线程这类事物的描述。
 * 就是Thread类
 *
 * 创建线程的第一种方式：继承Therad类
 * 步骤：
 * 1：定义类继承Teread类
 * 2：重写Thread类的run方法
 *         目的：将自定义的代码存储在run方法中，让线程运行
 * 3：调用线程的start方法
 *      2个作用 ：启动线程，调用run方法。
 *
 * 发现运行结果每一次都不同。
 * 因为多个线程都获取cpu的执行权，cpu执行到谁，谁就运行。
 * 明确一点，在猛一个时刻，只能有一个程序运行（多核除外）
 * cpu在做着快速的切换，以达到看上去是同时运行的效果。
 * 我们可以形象的把多线程的运行行为在互相抢夺cpu的执行权。
 *
 * 这就是多线程的一个特写：随机性，谁抢到谁执行，至于执行多长，cpu说的算
 *
 *为什么要覆盖run方法？
 *
 * Thread类用于描述线程。
 * 该类就定义看了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。
 * 也就是说Thread类中的run方法是用于存储线程要运行的代码。
 */
class Demo extends Thread{
public  void  run(){
    for (int x=0;x<60;x++)
    System.out.println("demo run----"+x);
}
}
public class 进程概述 {
    public static void main(String[] args) {
    Demo d=new Demo();//建立好一个对象，就是创建好一个线程
    d.start();//开启线程，并且执行该线程的run方法
    //d.run();//仅仅是对象调用方法，而线程创建了，并没有运行

    for (int x=0;x<=4000;x++){
        System.out.println("hello word--"+x);

       /*执行默认的run方法，run里面没有代码，没有任何变动
       Thread t =new Thread();
        t.start();*/
    }
    }
    }
